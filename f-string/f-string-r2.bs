<pre class='metadata'>
Title: String Interpolation and F-strings for C++
Abstract: This paper proposes string interpolation and f-strings for C++.
Editor: Hadriel Kaplan, hkaplan@juniper.net
Shortname: ????
Revision: 2
Audience: EWG
Status: D
Group: WG21
Date: 2023-10-10
Markup Shorthands: markdown yes
Markup Shorthands: biblio yes
Repository: https://github.com/hadrielk/cpp-proposals.git
Dark Mode: false
</pre>

Motivation
==========

Before this proposal:
```c++
int calculate(int);

std::string stringify(std::string_view prefix, int bits) {
    return std::format("{}:{}: got {} for {:#06x}", prefix, __LINE__, calculate(bits), bits);
}

void display(std::string_view prefix, int bits) {
    std::print("{}:{}: got {} for {:#06x}", prefix, __LINE__, calculate(bits), bits);
}
```

After this proposal:
```cpp
int calculate(int);

std::string stringify(std::string_view prefix, int bits) {
    return F"{prefix}-{__LINE__}: got {calculate(bits)} for {bits:#06x}";
}

void display(std::string_view prefix, int bits) {
    std::print(X"{prefix}-{__LINE__}: got {calculate(bits)} for {bits:#06x}");
}
```

The above shows two new mechanisms: an f-string and an x-string, denoted by `F""` and `X""` respectively.

F-strings are based on the same idea as python f-strings. They are wildly popular in modern python; arguably more popular than the python `str.format()` that the C++ `std::format()` was based on.

Many other programming languages also offer string-format interpolation, and use identical syntax. ([full list](https://en.wikipedia.org/wiki/String_interpolation#Examples))

X-strings (for "eXtracted String") have no equivalent in python. An x-string only extracts the expressions from the format-string, while an f-string invokes `std::format()` with them.

In other words, `F"..."` is just a convenient shorthand for `std::format(X"...")`.

The main benefit of f/x-strings is that it is far easier to see the argument usage locations, and it is less verbose.

For example in the code snippets above, in the second example it is easier to see that "`prefix`" goes before `__LINE__`, and "`bits`" is displayed in hex.

IDEs and syntax highlighters can support them as well, displaying the embedded expressions in a different color:

```python
    f"{prefix}-{__LINE__}: got {calculate(bits)} for {bits:#06x}"
```


Proposed Solution
==========

The proposed solution is simple from a logical perspective: it's just fancy preprocessing.

This:
```cpp
    F"{prefix}-{__LINE__}: got {calculate(bits)} for {bits:#06x}";
    std::print(X"{prefix}-{__LINE__}: got {calculate(bits)} for {bits:#06x}");
```

Would be converted to this by the preprocessor, assuming the first line number is `42`:
```cpp
    ::std::format("{}-{}: got {} for {:#06x}", prefix, 42, calculate(bits), bits);
    std::print("{}-{}: got {} for {:#06x}", prefix, 43, calculate(bits), bits);
```

To do that we define two new *preprocessing-token*s:

    1. An *f-string-literal* for `F"..."`.

    2. An *x-string-literal* for `X"..."`.

Both may also be combined with `R` as `FR""` or `XR""` to indicate raw string contents, as well as an *encoding-prefix*, for example `u8F""` or `LXR""`.

We also define three new operators in the preprocessor:

* A Cook unary operator ("`_Cook()`"), that accepts a single *string-literal* and converts it from a raw to a non-raw *string-literal*, or leaves it as-is if it was already non-raw. (see [[#cook]])

* A Concat variadic operator ("`_Concat()`"), that concatenates multiple arguments into one new longer *string-literal* or *identifier*. (see [[#concat]])

* An Extract unary operator ("`_Extract()`"), similar to the current Pragma operator, that accepts a single *string-literal*, modifies the string by extracting portions of it, and passes the modified string through phase-3 lexing and macro-invocation expansion.  (see [[#extract]])

During phase-4 of translation, while processing the list of preprocessing tokens as usual for macro-invocation, the preprocessor will:
1. Collect one or more sequential *f-string-literal*s or *x-string-literal*s into a group.
2. Convert the literals into normal *string-literal*s, separated by comma's.
3. Invoke "`_Extract( _Concat(literal0, ...) )`" with the list of *string_literal*s as the arguments, possibly wrapped within a `std::format()` if they were f-strings originally.

The Concat and Extract operators use the Cook operator internally, to convert raw-strings to non-raw, in order to simplify concatenation and interpolation.

Note that the Extract, Concat, and Cook operators know nothing about *f-string-literal*s or *x-string-literal*s - those types are converted to just *string-literal*s by the preprocessor beforehand, and nothing beyond phase-4 translation sees f-strings or x-strings.

See [[#preprocessing]] and [[#operators]] for further details.

Note: This proposal does not automatically make the definition of `std::format<>` available for f-strings - i.e., the user must still "`#include <format>`".


## Terminology

A formal grammar is descibed in later sections, but the relevant parts used throughout this document are shown here:
```cpp
       F"The result is { get_result() :d}"
//     ^~~~~~~~ f-string-literal ~~~~~~~~^
//                or f-string

       X"The result is { get_result() :d}"
//     ^~~~~~~~ x-string-literal ~~~~~~~~^
//                or x-string

       X"The result is { get_result() :d}"
//       ^~~~ interpolation-string ~~~~~^

       X"The result is { get_result() :d}"
//                     ^~~~~~~~~~~~~~~~~^
//                             |
//                      extraction-field

       X"The result is { get_result() :d}"
//                      ^~~~~~~~~~~~~^^~^
//                            |        |
//              output-argument    format-specifier
```


Limitations {#limitations}
==========

F-strings cannot do everything `std::format()` can do, and x-strings cannot do everything that explicit format parameters can do.

A non-exhaustive list of differences:
    1. Index-numbered format-string *replacement-field*s are not supported.
        - For example, `std::format("{0}{0}", a)` is not the same as `F"{a}{0}"`; the latter would become `format("{}{}", a, 0)`. One *can* do `F"{a}{a}"`, but that is not the same behavior.
    2. An f/x-string does not support double-quotes within the *extraction-field*.
        - For example, `std::format("{}", check("v"))` cannot be represented as `F"{check(\"v\")}"`.
        - This is not an unavoidable limitation, but rather an explicit choice of this proposal. (see [[#dquotes]])
    3. An f/x-string cannot be embedded within another.
        - For example, `std::format("{}", std::format("{}", a))` cannot be `F"{ F\"{a}\" }"`.
    4. String-literal types other than f/x-string-literals cannot be concatenated with f/x-string-literals. (see [[#multi-literals]])
    5. User-defined string-literals are not supported as the *interpolation-string*.
    6. Runtime-only *interpolation-string*s cannot be used, for obvious reasons.

But that's *ok*. Python f-strings also cannot do everything `str.format()` can do, and it hasn't caused mayhem nor prevented people from preferring to use f-strings.


FAQ
==========

## Why both F and X strings?

The initial draft began with *only* an f-string - i.e., always convert to invoking `std::format()`. Because that's the most common use-case, and follows what python does. The "f" literally stands for "formatted string". That's what it is and does, by-definition.

However, there was discussion on the mailing list regarding modifying the proposal to be a more-general string-interpolation mechanism. Concern was also raised about how to use the mechanism with `std::print()` and `println()` and such, which require a compile-time format-string and thus cannot use the `std::string` that `std::format()` would return.

So this paper does **both**: it provides an x-string for general string interpolation, which expands a string into separate arguments usable for functions like `std::print()`, as well as an f-string that performs string interpolation for `std::format()`.

At that point we *could* have removed f-strings entirely and only proposed x-strings, and forced users to either explicitly invoke `std::format()` or to create their own "f-string" using a preprocessor macro:
```cpp
#define FORMAT(...) ::std::format( _Extract( _Concat( __VA_ARGS__ ) ) )

auto s = FORMAT("iteration #{i + 1} out of {n}\n");
```

But given how widely popular f-strings are in python, this proposal keeps an `F""`-based f-string as a native feature, with the expectation that they will be popular in C++.

Users do not need to write any additional code to use an f-string, nor preprocessor macros. And from an implementation perspective, supporting f-strings is relatively trivial since they share the same underlying imeplementation of x-strings.


## Why should we support full expressions?

Some concerns were raised on the mailing list regarding allowing arbitrary expressions in the *extraction-field*, vs. only identifiers/lvalues.

The same concerns also came up when python added f-strings. But full expressions were ultimately supported in python because they were deemed too useful to exclude.

For example, the following types of uses would be very common:

```cpp
    F"number of entries: {vec.size()}";
    F"{key} exists: {map.contains(key)}";
    F"is valid: {opt.has_value()}";
    F"iteration #{i + 1} out of {n}";
    F"num missing: {total - found}";
```

Therefore, this proposal does support arbitrary expressions within f/x-string *extraction-field*s. In fact, technically they can be more than just expressions.

Allowing them has some downsides, however:

* Some expressions will create syntactic ambiguity for parsing the *extraction-field*.
* Compilation failure of the expressions in later phases of translation will be harder to correlate to the f/x-string's literal text.
* Code obfuscation is easier to achieve.
* Raw source-code scanners (linters, indexers, etc.) would need to parse f/x-strings to detect the expressions.

The above issues are discussed in more detail in later sections.


## Won't there be syntax ambiguity?

Syntactic ambiguity can arise due to the following:

* The format-specifier starts with a single colon, but expressions may also have single colons in them.
* The *extraction-field* ends with a closing-brace, but expressions may also end with a closing-brace, making it appear as an escape-sequence "}}".
* Expressions can include double-quotes when string-literals are used in them, which would lead to more ambiguity issues.

For example the first line of the following has a single colon `:` between `2` and `6`, which will be treated as separating an optional `format-spec`, and will thus convert but fail to compile later:
```cpp
    F"{check() ? 2 : 6}"; // ERROR: converts, but fails to compile later
```
Because the previous example converts to this:
```cpp
    ::std::format("{: 6}", check() ? 2); // ERROR
```

The same issue arose for python (due to their lambda syntax), and their chosen solution was to require any such expression to be wrapped by parentheses.

This proposal chooses that same solution:
```cpp
    F"{(check() ? 2 : 6)}";      // ok
    F"{(check() ? 2 : 6):#04x}"; // ok
    F"{(some_type{})}";          // ok
```

The rationale for this is that it is simple to parse and detect during preprocessing, and it remains consistent with python just as `std::format()` does.


## Why can't we use escaped double-quotes inside? ## {#dquotes}

There are syntax ambiguity issues if we allowed double-quotes.

The Extract operator could keep track of double-quotes within the *extraction-field*, but it would require two-stage escaping to handle all cases:
```cpp
    F"{( func(\"\\\")}\") )}";
    // same as above, but in raw-string form
    FR"({( func("\")}") )})";
```

But that would require unescaping non-raw literals during parsing of the *interpolation-string*, just to determine where an *extraction-field* ends; as well as simultaneously tracking quoted regions to ignore delimiters within them.

Furthermore, many programmers become confused by extra layers of escaping even today, for cases such as regex patterns.

Therefore this proposal does not currently support the use of double-quotes within *extraction-field*s.

Of course this decision can be changed, should the WG so decide.


## Why do it in the preprocessor?

String interpolation could have been done in a later phase of translation, as a previous paper [[P1819R0]] proposed.

However doing so would have meant that any macros in the original interpolation string would not be expanded/replaced in the output, and cause compilation failure instead.

C functions are sometimes implemented as macros, such as `abs()` or `max()` in some implementations. And of course there are user or library defines as well.

Many programmers do not even know they are invoking function-like macros vs. functions, or object-like macros vs. static values.

Furthermore, some standardized and compiler-specific macros are widely used for debugging, such as `__FILE__` and `__LINE__`, etc.

The preprocessor also offers a clean separation between what is and is not native C++ code. And the contents of the pre-interpolated string is *not* native C++ code (at least, not *yet*).

Users also likely expect it to behave like textual transformation, as if it replaced the original string with new substrings of code. So this proposal does what users think it does.

Performing the interpolation within the preprocessor does have some drawbacks, however:

* Multiple, separate string-literals must all be of the same type: an *f-string-literal* or *x-string-literal*, but not both. (see [[#multi-literals]])

* Macros cannot be used to create separate *string-literal*s for the f/x-strings in all cases. (see [[#macro-literals]])

* We cannot prevent "creative" uses of the f/x-string from generating somewhat arbitrary code.

* Some errors will not be detected until later phases of translation, making it harder to correlate to the root cause. (i.e., similar to macro-based issues today)


## Why do we need multiple preprocessor operators?

This proposal is technically achievable with just one new operator: the Extract operator, which could just do the other operators' work internally.

But separating the discrete steps into multiple operators provides several advantages:

* It provides more flexibility for programmers who wish to create their own function-like macros. For example if their macro needs to perform other work in-between the steps, or only some of the steps.

* The Concat operator is generally useful by itself, since it can do things `##` cannot: it can concatenate *string-literals* during preprocessing, and it can concatenate *identifier*s with expanding macros. The former functionality can allow one to pass multiple *string-literals* to the Pragma operator, for example. The latter functionality avoids needing to use a level of macro indirection.

* The Cook operator is generally useful by itself, since converting raw-strings to non-raw is a useful ability. For example the Pragma operator does not currently accept a raw-string *string-literal*, but can easily be used with one by invoking `_Pragma( _Cook(s) )`.

* It provides separate customization points, if the compiler implementation wishes to expose command options to override a specific operator with a custom one.


## What about multiple literals? ## {#multi-literals}

It is common practice to split long string literals across lines. For example:
```cpp
    std::cout << "some long string literal of characters "
                 "continued by another string literal";
```

This proposal does support the above scenario, but only when all of the literals are of the same type:
```cpp
1. F"{name}:" F" got {value}" // ok
2. X"{name}:" X" got {value}" // ok
3.  "{name}:" F" got {value}" // ERROR
4. F"{name}:"  " got {value}" // ERROR
5. F"{name}:" X" got {value}" // ERROR
```

Note that this is more restrictive than for existing string-literal types. Many existing string-literals can be concatenated with other types, although not all can.

The reasons for this restriction:
    1. While an `F""` or `X""` might appear similar to `R""` or encoding-prefixes, they are arguably different: they're more like a command or macro invocation, as well as a format specifier. It is not logical to expect line 3 above to work, when one views the `F""` in that way.
    2. Supporting line 3 above would require the preprocessor to either backtrack, or to peek ahead for *every* string-literal token in the source. Both of these options are undesirable.
    3. Due to the above two reasons, if line 3 in the example is not supported, then line 4 should not be either - to be consistent, no matter which literal type comes first.
    4. Line 5 in the example is likewise illogical, as it is requesting two different actions to occur.

Note that raw-strings do not affect concatenation, nor do *encoding-prefix*es if there is a common encoding:
```cpp
return F"{name}:"   FR" got {value}"; // ok
return LFR"{name}:"  F" got {value}"; // ok, common encoding is wide-string
return FR"{name}:" u8F" got {value}"; // ok, common encoding is UTF-8
return LF"{name}:" u8F" got {value}"; // ERROR: no common encoding
```

Note: Despite the same-literal-type restrictions, some use-cases may succeed anyway, coincidentally. See [[#unexpected]].


## Macro-generated String Literals ## {#macro-literals}

Programmers are accustomed to using macros that expand to strings literals. For example:
```cpp
    printf("value is %" PRIu32 "\n", value);
    printf("value is " COLOR_RED "%s" COLOR_CLEAR "\n", value);
    std::cout << GEN_STRINGS(x, y, z) << "\n"; // macro creates multiple literals
```

But for this proposal's mechanisms, the macros must be in *extraction-field*s of the *interpolation-string* used in the f/x-string-literal.

In other words:
```cpp
    F"value=" COLOR_RED F"{value}" COLOR_CLEAR;             // ERROR
    std::print(X"value=" COLOR_RED X"{value}" COLOR_CLEAR); // ERROR

    F"value={COLOR_RED} {value} {COLOR_CLEAR}";             // ok
    std::print(X"value={COLOR_RED} {value} {COLOR_CLEAR}"); // ok
```

However, this is a reasonable requirement, because the whole point of this proposal is to use the format-string style with the variables inside the string, where they're used.

Furthermore, the preprocessor is only a one-pass transformer, so even if it "peeked" at the next preprocessing-token(s), it wouldn't expand token `COLOR_RED` into its replacement literal yet.


F/X-String-Literal Processing {#preprocessing}
==========

## Grammar

The *preprocessing-token* in [lex.pptoken] is extended to include:

    : *f-string-literal*:

    ::    *encoding-prefix*<sub>opt</sub> F " s-char-sequence<sub>opt</sub> "

    ::    *encoding-prefix*<sub>opt</sub> FR *raw-string*

    : *x-string-literal*:

    ::    *encoding-prefix*<sub>opt</sub> X " s-char-sequence<sub>opt</sub> "

    ::    *encoding-prefix*<sub>opt</sub> XR *raw-string*

The above *f-string-literal* and *x-string-literal* are only defined for *preprocessing-token*s because they do not exist after phase-4 translation.

The character sequences within the above literals are further constrained by the grammar described in later sections of this proposal; however those grammar rules are only used within the operation of the Extract operator, during phase-4 translation, and are thus not part of the language syntax.


## Processing Details

While the preprocessor is performing macro-invocation expansion during translation phase-4, it shall also process *f-string-literal* and *x-string-literal* *preprocessing-token*s as if they were macro invocations.

However unlike other macro invocations, multiple sequential *f-string-literal*s, or multiple sequential *x-string-literal*s, need to be processed together as one group.

The following macros are used for the purpose of describing the procedures below, but are not actually defined in the program:
```cpp
    #define _Xstring(...) _Extract( _Concat(__VA_ARGS__) )
    #define _Fstring(...) ::std::format( _Extract( _Concat(__VA_ARGS__) ) )
```

When a *preprocessing-token* is a *f-string-literal*:

    1. Every *f-string-literal* direcly following this one, is part of the same group as this one.

    2. Each literal in the group has its '`F`' mark removed, to form *string-literals*, and commas are inserted between members if there is more than one.

    3. The list of *string-literals* is then replaced by the macro-invocation of the `_Fstring()` macro with the comma-separated *string-literals* as arguments.


For example:
```cpp
    LF"k={v}";
    // logical processing steps
    // 1. => L"k={v}";
    // 2. => ::std::format( _Extract( _Concat( L"k={v}" ) ) );

    F"a={i}" FR"b={j}" F"c={k}";
    // logical processing steps
    // 1. => "a={i}" R"b={j}" "c={k}"
    // 2. => "a={i}", R"b={j}", "c={k}"
    // 3. => ::std::format( _Extract( _Concat( "a={i}", R"b={j}", "c={k}" ) ) )
```

When a *preprocessing-token* is an *x-string-literal*:

    1. Every *x-string-literal* direcly following this one, is part of the same group as this one.

    2. Each literal in the group has its '`X`' mark removed, to form *string-literals*, and commas are inserted between members if there is more than one.

    3. The list of *string-literals* is then replaced by the macro-invocation of the `_Xstring()` macro with the comma-separated *string-literals* as arguments.

For example:
```cpp
    LX"k={v}";
    // logical processing steps
    // 1. => L"k={v}";
    // 2. => _Extract( _Concat( L"k={v}" ) );

    X"a={i}" XR"b={j}" X"c={k}";

    // logical processing steps
    // 1. => "a={i}" R"b={j}" "c={k}";
    // 2. => "a={i}", R"b={j}", "c={k}";
    // 3. => _Extract( _Concat( "a={i}", R"b={j}", "c={k}" ) );
```


New Preprocessor Operators {#operators}
==========

## The Cook operator ## {#cook}

A new preprocessor `_Cook()` unary operator is proposed, which converts a raw-string *string-literal* to a non-raw *string-literal*, of any *encoding-prefix*.

The Cook operator can be used during macro expansion, as well as directly during macro-invocation as if it were a defined macro name.

Before `_Cook()` invocation, any *pp-tokens* between the parentheses are processed per the rules for Argument Substitution [cpp.subst], as is done for arguments of function-like macros.

The result of argument substitution shall be a single *string-literal* or the program is ill-formed.

`_Cook()` is then invoked with the single *string-literal* argument, which is processed as folows:

    1. If the *string-literal* is not a raw-string denoted by '`R`', conversion is complete.

    2. The '`R`' prefix is removed.

    3. The *d-char-sequence* and parentheses delimiters on both ends are removed.

    4. Each backslash character within the string is escaped by replacing it with the "`\\`" escape sequence.

    5. Each double-quote character within the string is escaped by replacing it with the "`\"`" escape sequence.

    6. Each newline character within the string is escaped by replacing it with the "`\n`" escape sequence.

The resulting *string-literal* replaces the original four preprocessing tokens.


## The Concat operator ## {#concat}

A new preprocessor `_Concat()` variadic operator is proposed, which concatenates two or more *preprocessing-token*s into one *preprocessing-token*, for specific token types.

It is logically similar to the `##` operator, but with the following differences:

    - Arguments are substituted via full macro expansion before concatenation; whereas the `##` operator inhibits argument substitution.

    - Two or more *string-literal*s are concatenated into a new *string-literal*, for specific supported combinations; whereas the `##` operator does not support concatenating two *string-literal*s of any type.

    - Concat is left-associative for order-of-precedence, while `##` operator is unspecified for such.

Note that the Concat operator does also support concatenating two or more *identifier*s without any *string-literal*s. In that sense it is identical to the `##` operator except for also performing argument substition. This latter difference makes it potentially useful generally, to avoid needing the extra macro for indirection that programmers frequently need to add today.

The Concat operator has the expression form:
```
        _Concat( concat-args )
```

### Internal Grammar

The following grammar is used in subsequent sections to describe Concat processing rules:

    : *concat-args*:
    ::    *string-literal-list*
    ::    *identifier-string-list*
    ::    *identifier-list*

    : *identifier-string-list*:
    ::    *identifier-list* , *string-literal-list*

    : *string-literal-list*:
    ::    *string-literal*
    ::    *string-literal* , *string-literal*

Note that one or more *identifier*s may appear before *string-literal* types, but not after; or the args can be comprised of only one or more *identifier*s, or only one or more *string-literal*s.

Also note that the above grammar does not need to be added to the overall language syntax, since it is only used to describe the internal processing within the Concat operator.


### Processing Details

The Concat operator can be used during macro expansion, as well as directly during macro-invocation as if it were a defined macro name.

Before `_Concat()` invocation, the arguments are processed per the rules for Argument Substitution [cpp.subst], as is done for arguments of function-like macros.

The Concat operator is usable within that substitution, and thus arguments may invoke `_Concat()` as well. Such concatenation would complete before the outer `_Concat()` would be invoked.

For example:
```cpp
    #define prefix L
    #define fmtstr(s) _Concat("{", s, "}")

    _Concat( prefix, fmstr("bar") )

    // logical processing steps
    // 1. => _Concat( L, fmstr("bar") )
    // 2. => _Concat( L, _Concat("{", "bar", "}") )
    // 3. => _Concat( L, "{bar}" )
    // 4. => L"{bar}"
```

After argument substitution is complete, the new *pp-tokens* must be valid *concat-args*, per the grammar rules listed earlier.

The `_Concat()` invocation then begins with the *concat-args* for arguments, and performs the following:

    * If the *concat-args* is an *identifier-list*, processing follows the rules in [[#identifier-concat]] below.

    * If the *concat-args* is a *string-literal-list*, processing follows the rules in [[#string-concat]] below.

    * If the *concat-args* is an *identifier-string-list*:

        1. The *identifier-list* portion is processed as per [[#identifier-concat]] below.

        2. The *string-literal-list* portion is processed as per [[#string-concat]] below.

        3. The resulting *identifier* is concatenated with the resulting *string-literal* to produce a new *string-literal* token.

            - For example, a `_Concat(L, "foo", "bar")` would generate the *string-literal* token `L"foobar"`.

            - But `_Concat(A, "foo", "bar")` would produce an error, because `A"foobar"` is not a valid *string-literal*.

    * The resulting *identifier* or *string-literal* replaces the original sequence of tokens from `_Concat( pp-tokens )`.


#### Identifier Concatenation #### {#identifier-concat}

If there is only one *identifier* in the *identifier-list*, it is left alone and identifier concatenation is complete.

Otherwise, each *identifier* in the *identifier-list* is concatenated together left-to-right to form a single *identifier*, without further macro expansion, and the resulting *identifier* replaces the *identifier-list*.

In other words, the result is logically equivalent to the `##` operator being applied between each *identifier*, if there is more than one.

Note: Argument substitution already occured before `_Concat()` was invoked, and thus macro expansion has already taken place before identifier concatenation.


#### String-literal Concatenation #### {#string-concat}

Each *string-literal* in the *string-literal-list* is processed sequentially as follows:

    1. If there is no *string-literal* following the current one, the current *string-literal* replaces the original *string-literal-list* and concatenation is complete.

    2. A common *encoding-prefix* for the resulting concatenated *string-literal* is determined based on the current and next *string-literal*:

        - If both *string-literal*s have the same *encoding-prefix*, the common *encoding-prefix* is that one.

        - If one *string-literal* has no *encoding-prefix*, the common *encoding-prefix* is that of the other's.

        - Any other combination is ill-formed.

    3. If the current *string-literal* is a raw-string, then it is converted to non-raw as if the Cook operator were invoked with that *string-literal*.

    4. If the next *string-literal* is a raw-string, then it is converted to non-raw as if the Cook operator were invoked with that *string-literal*.

    4. The two character sequences are concatenated, wrapped in double-quotes, and the *encoding-prefix* is set to the common *encoding-prefix* determined above.

    5. The single resulting *string-literal* replaces the two original *string-literal*s.


## The Extract operator ## {#extract}

A new preprocessor `_Extract()` operator is proposed, which accepts a single *string-literal* (after argument substitution) and replaces it with an extracted sequence comprising a *format-string* *string-literal* followed by zero or more *pp-tokens*.

### Internal Grammar

The following grammar is used in subsequent sections to describe Extract processing rules:

    : *interpolation-string*:
    ::    *extraction-field*
    ::    *extraction-field* *interpolation-string*
    ::    *fmt-char*
    ::    *fmt-char* *interpolation-string*

    : *extraction-field*:
    ::    { *output-argument* *fmt-specifier*<sub>opt</sub> }

    : *output-argument*:
    ::    ( *any member of the source character set except the double-quote or the matching right parenthesis* )
    ::    *any member of the source character set except the double-quote or colon*

    : *fmt-char*:
    ::    *fmt-escape*
    ::    *any member of the source character set except the double-quote or left brace*

    : *fmt-escape*:
    ::    { {
    ::    } }

    : *fmt-specifier*:
    ::    : *fmt-spec*

    : *fmt-spec*:
    ::    *fmt-spec-chars*
    ::    *fmt-spec-chars* *fmt-spec*
    ::    *fmt-spec-extract*
    ::    *fmt-spec-extract* *fmt-spec*

    : *fmt-spec-extract*:
    ::    { *fmt-spec-char* }

    : *fmt-spec-chars*
    ::    *fmt-spec-char*
    ::    *fmt-spec-char* *fmt-spec-chars*

    : *fmt-spec-char*
    ::    *any member of the source character set except the double-quote, left brace, or right brace*

    : *output-string*:
    ::    *the character sequence for a "format string" defined in [format.string]*


### Processing Details

The Extract operator can be used during macro expansion, as well as directly during macro-invocation as if it were a defined macro name.

Before `_Extract()` invocation, any *pp-tokens* between the parentheses are processed per the rules for Argument Substitution [cpp.subst], as is done for arguments of function-like macros.

For example:
```cpp
    #define S "{num}"
    _Extract(S)
    // logical processing steps
    // 1. => _Extract( "{num}" )
    // 2. => "{}", num
```

After argument substitution is complete, the character contents of the *string-literal* must match the syntax of *interpolation-string*, as defined by the grammar previously. The *string-literal* may be a raw-string, of any *encoding-prefix*.

If the *string-literal* is a raw-string, it first converted to a non-raw as if the Cook operator were invoked with the *string-literal*.

Note: To describe the processing rules herein, the terms "output-string" and "output-arguments" are used. They do not represent tokens, but rather placeholders used during the processing of the *string-literal* to produce an intermediate character sequence, which will then be passed through phase-3 lexing.

The contents of the characters within the *string-literal* are processed as if parsed into the grammar for *interpolation-string* described previously. Note that this includes handling of the *output-argument* field being wrapped in parentheses.

Each character that is not part of an *extraction-field* is copied verbatim into the output-string, including *fmt-escape*s.

    - Example: '`a \"{{( {b}`' becomes the output-string '`a \"{{( {}`' with output-argument '`b`'.

    - Example: '`a{{{b}}}`' becomes the output-string '`a{{{}}}`' with output-argument '`b`'.

    - Example: '`a{{b`' becomes the output-string '`a{{b`' with no output-arguments.

Each *extraction-field* is processed as follows:

    1. The opening left-brace of the *extraction-field* is copied to the output-string.

    2. The *output-argument*'s character sequence, ignoring a leading left-parentheses and matching trailing right-parenthesis, is processed as follows:

        - The character sequence is copied verbatim to an output-argument.

        - The character sequence must not have a mismatching set of parentheses, or else the program is ill-formed.

    3. If a *format-specifier* exists, its character sequence is processed as follows:

        - The leading colon is copied to the output-string.

        - The character sequence must not have a mismatching set of parentheses, or else the program is ill-formed.

        - Each *fmt-spec-extract*'s character sequence is processed as an *output-argument* per (2) above.

            - The opening left-brace and closing right-brace are copied to the output-string.

        - Any *fmt-spec-chars* not in a *fmt-spec-extract* are copied verbatim to the output-string.

    4. The closing right-brace of the *extraction-field* is then also copied to the output-string.


The *encoding-prefix* of the original *string-literal* is set to the of *encoding-prefix* the output-string. Each new output-argument created by the above steps, causes a comma "`,`" and the output-argument to be appended after the output-string, after the closing double-quotes and any previous output-arguments.

    - Example: `L"{a}{b}"` becomes the character sequence '`L"{}{}", a, b`'.

    - Example: `"a"` becomes the character sequence '`"a"`'.

After the *string-literal* has been converted to the separated output-string and output-arguments, theey are processed through lexing translation phase-3 to produce *preprocessing-token*s.

The resulting sequence of *preprocessing-token*s from lexing are then processed for macro-invocation expansion, as defined for translation phase-4.

Note: Preprocessing directives shall not be usable within this expansion even if the tokens resemble one; but all Cook, Concat, Extract, and Pragma operator expressions are usable.

The resulting final sequence of preprocessing tokens then replace the original four preprocessing tokens of the `_Extract` unary operator expression.


Extending and Customizing
==========

## Customization Points

As defined in this proposal, there is no customization available. For example one could not use a different library implementation in place of `std::format()` for f-strings, such as `fmt::format()`.

The user can instead invoke `fmt::format(X"...")` should they wish to, or even create a preprocessing function-like macro such as:
```cpp
#define FMT(...) ::fmt::format( _Extract( _Concat( __VA_ARGS__ ) ) )

auto s = FMT("iteration #{i + 1} out of {n}\n");
```

## Future Proofing

A concern raised on the mailing list regards future-proofing: what if a new `std::format2()` were created? How would we switch to that?

We think the answer is: C++ would just update the specification to make it use `std::format2()`, for that version of C++, if it's sufficiently compatible.

Even in terms of ABI stability: so long as a standard library implementation does not itself *use* an f/x-string in its publicly visible code or ABI, its ABI would not change nor would we run afoul of the one-definition-rule.

Because an f/x-string is not a C++ type or data structure. It cannot cross any boundaries. It is more akin to a preprocessing function-like macro.

If a new format syntax is *not* sufficiently compatible, then by-definition it requires the programmer to change all using code *anyway*, to use the new format. It would require a new operator and *preprocessing-token*. See [[#c-usage]] for an example.


## Usage in C ## {#c-usage}

A concern raised on the mailing list regards the usability of this new mechanism in C. What good would it do for the C-preprocessor to have the Extract operator, when no C-function can use the format-string syntax?

Of course C *could* add a `printfmt()` function that accepts a format-string syntax, just without the argument-type aspects that C++ provides.

But suppose WG14 wanted to make `printf()` and similar functions usable with this proposal's string interpolation. Then how do we get something like this to work?:
```c
    printf("iteration #{i+1:d} out of {name:s}\n");
```

We believe that the answer is: WG14 would add another preprocessor operator: one that converts the format-string syntax to `printf` syntax *after* the Extract operator has interpolated. And they might also define a new *preprocessing-token* to invoke their new operator.

For example, a variadic `_FmtToC()` operator that converts its first *string-literal* argument's braces "`{}`" to percent encoding, and a new *p-string-literal* *preprocessing-token* to invoke it correctly.

For example:
```c
    // a new P-string-literal P"" will invoke something like this, from a logical perspective:
    #define _Pstring(...) _FmtToC( _Extract( _Concat( __VA_ARGS__ ) ) )

    printf(P"iteration #{i+1:d} out of {name:s}\n");

    // logical processing steps
    // 1. => printf( _FmtToC( _Extract( _Concat( "iteration #{i+1:d} out of {name:s}\n" ) ) ) )
    // 2. => printf( _FmtToC( _Extract( "iteration #{i+1:d} out of {name:s}\n" ) ) )
    // 3. => printf( _FmtToC( "iteration #{:d} out of {:s}\n", i+1, name ) )
    // 4. => printf( "iteration #%d out of %s\n", i+1, name  )
```


Failure/Edge Cases
==========

## Constraining What F/X-Strings Can Do

The contents of the f/x-strings may include somewhat arbitrary code, such that the resulting sequence of tokens do more than what this proposal was intended for.

For example, this generates more arguments than the format-string has replacement fields for, which will even successfully compile later because it is allowed:
```cpp
    std::print(X"{foo, func()}");
    // => std::print("{}", foo, func()); // ok, extra arg is ignored by print()

    return F"{foo, func()}";
    // => return std::format("{}", foo, func()); // ok, extra arg is ignored by format()
```

Note that the extra `func()` above would still be invoked, and side-effects still occur.


And this example uses the comma operator's behavior to perform unrelated work:
```cpp
    if (X"{func()}{check()}") return;
```

The above would be converted to this:
```cpp
    if ("{}{}", func(), check()) return; // ok, but weird
```

Due to the `"{}{}"` string-literal above having no effect, some implementations might generate a diagnostic, but not all do. For example, by default `clang` generates a warning, but `gcc` and `msvc` do not.

However this proposal *does* require the Extract operator to verify the final output tokens have balanced parentheses.

Thus the following scenario is prevented:
```cpp
    std::cout << F"{key); if (map.contains(key)) abort(}"; // ERROR
    if (map.contains(key)) { ... }

    // the above would have generated this if it were allowed:
    std::cout << ::std::format("{}", key); if (map.contains(key)) abort();
    if (map.contains(key)) { ... }
```

The rationale for preventing the above is to detect errors at the point of use, since mismatched parentheses are likely programmer error.

Of course another option is for this proposal to only require diagnostics in such cases, but still allow translation to succeed.


## Expression Syntax Clashes

One potential for confusion is that not every arbitrary expression will work inside of the *extraction-field*.

For example the first line of the following has a single colon `:` between `2` and `6`, which will be treated as separating an optional format-spec, and will thus convert but fail to compile later:
```cpp
    F"{check() ? 2 : 6}";   // ERROR: converts, but fails to compile later
    F"{(check() ? 2 : 6)}"; // ok
```
Because the previous example converts to this:
```cpp
    ::std::format("{: 6}", check() ? 2);  // ERROR
    ::std::format("{}", check() ? 2 : 6); // ok
```

Ternary expressions are not the only case a single colon can appear in C++ expresions. For example they appear within range-based for-loops, switch-case statements, and labels. Reflection's splicing syntax also uses single colons in the current proposals.


Likewise the alternative tokens (digraphs) `<:` and `:>` can also cause issues for similar reasons:
```cpp
    F"{my_vector[42]}";     // ok
    F"{my_vector<:42:>}";   // ERROR: fails to compile later
    F"{(my_vector<:42:>)}"; // ok
```

Or the expression might end with a closing brace, and clash with the *extraction-field*'s closing brace to appear as an escape-sequence:
```cpp
    F"{some_type{}}";   // ERROR: mismtached braces
    F"{some_type{} }";  // ok
    F"{(some_type{})}"; // ok
```

## Unexpected Results ## {#unexpected}

Despite the Limitations ([[#limitations]]) section stating that mixing of x-strings with non-x-strings is not supported, it will succeed in certain cases.

For example:
```cpp
std::print("foo" X"{bar}");
// => std::print("foo" "{}", bar); // phase-4 extracted
// => std::print("foo{}", bar);    // phase-5 concatenated
```

The above will successfully compile, because translation phase-5 will concatenate the two string-literals into one.

And if only runtime format checking is performed, then invalid formats won't be detected at compile-time:
```cpp
std::vformat("{foo}" X"{bar}");
// => std::vformat("{foo}" "{}", bar); // phase-4 extracted
// => std::vformat("{foo}{}", bar);    // phase-5 concatenated
```


Safety And Security Considerations
==========

## Unsafe Usage

X-strings do not add any new unsafe conditions that did not already exist for the extracted expressions.

F-strings do not add any new unsafe conditions that did not already exist for `std::format`. For example any access to invalid memory locations within expressions from *extraction-field* would have also occured for explicit arguments to `std::format()`.

The returned `std::string` from the f-string's converted-to `std::format()` call is a prvalue and subject to the lifetime rules for such.

Raw source-code scanners do need to be updated to parse f/x-string content in order to detect the expressions within. If such a scanner is used for safety or compliance checks, it will need to be updated. However, this is also true for many new C++ language changes, so it should not be a surprise.


## Security Considerations

Allowing f/x-strings to contain arbitrary C++ expressions within a literal string, and generating new code based on them, opens a new opportunity for code obfuscation.

Consider:
```cpp
    if (X"{abort()}{check()}") return;
```

The above would be converted to this:
```cpp
    if ("{}{}", abort(), check()) return;
```

The above is valid code, due to the comma operator's behavior, and `abort()` will be invoked.

Although this is a new avenue for obfuscation, similar obfuscation can already be achieved today with traditional preprocessor macros.

The good news is that the format-string cannot be generated at runtime from external input. And being in the f/x-string makes it more visible/exposed than via preprocessor macros.


Prior Work
==========

A previous proposal [[P1819R0]] already proposed to add f-string support for C++, but in a fundamentally different way than this one.

[[P1819R0]] would make f-strings into first-class C++ language constructs. An f-string would be interpolated and generate what is basically an unnamed lambda; one that satisfies a new "InterpolatedLiteral" concept. This unnamed callable would then be passed as a parameter to using functions that accept it and invoke it to do whatever. For example `std::ostream` would be modified to accept any type satisfying "InterpolatedLiteral", and thereby allow one to do "`std::cout << f"{bar}";`".

This unnamed pseudo-lambda would capture all variables by reference, and needs to be invoked by being given *another* callable, and that second callable is invoked with all the separate pieces of the interpolated literal. See [[P1819R0]] for the type of code one would need to write to handle this.

While the proposed mechanism in [[P1819R0]] is clever and highly customizable after interpolation, it's also complicated to add support for, and does not support format specifiers. It would also be difficult to diagnose compilation errors for, because they would happen somewhere else in the middle of template-instantiated callable code.

Furthermore, [[P1819R0]] requires every *using* function to be changed, to handle invoking the callable and its generated types.

This proposal, on the other hand, performs the interpolation in a relatively straight-forward manner. It is easy to easy to understand, easy to diagnose errors for, etc. It also supports format specifiers, including user-defined ones.

No other code needs to change to handle a callable. Nothing needs to be captured. There's no additional complexity.


Acknowledgements
==========

I would like to thank the members of the std-proposals maling list for their time and discussion. Their feedback significantly improved the proposed solution.


Changes
==========

## Changes From Draft Revision-1

1. Changed the conversion to be performed in stage-4 preprocessing, due to the need to support macros within the string.

    - This changed large portions of the document, and added operators, new examples, etc.

2. Added support for multiple f/x strings to be concatenated.

3. Specified balanced parentheses in the extraction-field, to prevent arbitrary unexpected code to be generated.

4. Restricted using double-quotes in extraction-field.

5. Added details for how it works, and the grammar.

6. Added justifications for restrictions/limitations.

7. Added section about usage in C.

8. Removed most mentions of [[P1819R0]], and only discuss it in one subsection.


## Changes From Draft Revision-0

1. Added the notion of an x-string ("eXtracted String" or "eXpanded String"?) separate from an f-string, based on discussions on the mailing list.

2. Changed the handling of the colon format-spec delimiter: in rev-0 the last standalone colon was considered the delimiter; whereas in rev-1 the *first* standalone colon is.

    - This was done to follow the behavior of `std::format()`, to allow things like `F"The time is { chrono::system_clock::now() :HH:MM:SS}"`.

3. Added the ability to use parentheses to wrap an expression, to avoid syntax ambiguity issues.

4. Added several new sections based on discussion on the mailing list, as well as sections for safety and security.

5. Removed the text and code example for a potential customization point. It wasn't technically part of the proposal, and added confusion I think.
